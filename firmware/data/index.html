<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotator Control</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background-color: #2c3e50;
            color: white;
            padding: 10px 0;
            text-align: center;
            margin-bottom: 20px;
        }
        h1 {
            margin: 0;
        }
        .card {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .status {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        .status-item {
            text-align: center;
            flex: 1;
        }
        .status-value {
            font-size: 24px;
            font-weight: bold;
        }
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        button {
            padding: 10px;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #2980b9;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .color-preview {
            width: 30px;
            height: 30px;
            display: inline-block;
            margin-left: 10px;
            border: 1px solid #ccc;
            vertical-align: middle;
        }
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
            border-radius: 5px 5px 0 0;
        }
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            color: #333;
        }
        .tab button:hover {
            background-color: #ddd;
        }
        .tab button.active {
            background-color: #3498db;
            color: white;
        }
        .tabcontent {
            display: none;
            padding: 20px;
            border: 1px solid #ccc;
            border-top: none;
            border-radius: 0 0 5px 5px;
            background-color: white;
        }
        .active-tab {
            display: block;
        }
        .loading {
            text-align: center;
            margin: 20px 0;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden {
            display: none;
        }
        #ota-form {
            margin-top: 20px;
        }
        #ota-progress {
            width: 100%;
            height: 20px;
            background-color: #f3f3f3;
            margin-top: 10px;
            border-radius: 5px;
            overflow: hidden;
        }
        #ota-progress-bar {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            transition: width 0.3s;
        }
        #ota-status {
            margin-top: 10px;
            font-weight: bold;
        }
        
        /* Status message styles */
        .success {
            color: #4CAF50;
            background-color: #f0f8f0;
            border: 1px solid #4CAF50;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .error {
            color: #F44336;
            background-color: #fdf0f0;
            border: 1px solid #F44336;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .info {
            color: #2196F3;
            background-color: #f0f4ff;
            border: 1px solid #2196F3;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        /* Debug tab styles */
        .debug-controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        
        .debug-controls button {
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .debug-status {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
        
        .plot-container {
            margin-bottom: 30px;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow: hidden; /* Prevent content from overflowing */
        }
        
        .plot-container h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .plot-container canvas {
            border: 1px solid #ddd;
            border-radius: 3px;
            display: block;
            margin: 0 auto;
            max-width: 100%; /* Make canvas responsive */
            height: auto; /* Maintain aspect ratio */
        }
        
        .plot-legend {
            margin-top: 10px;
            text-align: center;
        }
        
        .legend-item {
            display: inline-block;
            margin: 0 15px;
            font-size: 14px;
        }
        
        .legend-color {
            display: inline-block;
            width: 20px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .plot-container canvas {
                width: 100%;
                height: auto;
            }
            
            .legend-item {
                display: block;
                margin: 5px 0;
                text-align: center;
            }
            
            .debug-controls button {
                width: 100%;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Rotator Control v1.1</h1>
    </header>
    
    <div class="container">
        <div class="card">
            <div class="status">
                <div class="status-item">
                    <div>Current Position</div>
                    <div class="status-value" id="current-angle">-</div>
                    <div id="current-position-counts">-</div>
                </div>
                <div class="status-item">
                    <div>Current Color</div>
                    <div class="color-preview" id="current-color"></div>
                </div>
                <div class="status-item">
                    <div>Auto Rotation</div>
                    <div class="status-value" id="auto-rotation-status">-</div>
                </div>
            </div>
        </div>
        
        <div class="tab">
            <button class="tablinks active" onclick="openTab(event, 'control')">Control</button>
            <button class="tablinks" onclick="openTab(event, 'wifi')">WiFi</button>
            <button class="tablinks" onclick="openTab(event, 'settings')">Settings</button>
            <button class="tablinks" onclick="openTab(event, 'calibration')">Calibration</button>
            <button class="tablinks" onclick="openTab(event, 'motion-control')">Motion Control</button>
            <button class="tablinks" onclick="openTab(event, 'debug')">Debug</button>
            <button class="tablinks" onclick="openTab(event, 'updates')">Updates</button>
        </div>
        
        <!-- Control Tab -->
        <div id="control" class="tabcontent active-tab">
            <h2>Rotate</h2>
            <div class="action-buttons">
                <button onclick="rotate(0)">0째</button>
                <button onclick="rotate(90)">90째</button>
                <button onclick="rotate(180)">180째</button>
                <button onclick="rotate(270)">270째</button>
            </div>
            
            <h2>Auto Rotation</h2>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="auto-rotation-toggle" onchange="toggleAutoRotation()">
                    Enable Auto Rotation
                </label>
            </div>
            <div class="form-group">
                <label for="rotation-interval">Rotation Interval (seconds)</label>
                <input type="number" id="rotation-interval" min="5" value="60">
                <button onclick="saveRotationInterval()">Save</button>
            </div>
        </div>
        
        <!-- WiFi Tab -->
        <div id="wifi" class="tabcontent">
            <h2>WiFi Configuration</h2>
            
            <div class="card">
                <h3>Current Connection Status</h3>
                <div class="status">
                    <div class="status-item">
                        <div>Status</div>
                        <div class="status-value" id="wifi-status">-</div>
                    </div>
                    <div class="status-item">
                        <div>IP Address</div>
                        <div class="status-value" id="wifi-ip">-</div>
                    </div>
                    <div class="status-item">
                        <div>mDNS Name</div>
                        <div class="status-value" id="wifi-mdns">-</div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h3>Connect to WiFi Network</h3>
                <p>Scan for available networks and connect to your WiFi router.</p>
                
                <div class="form-group">
                    <button onclick="scanNetworks()" id="scan-button">Scan for Networks</button>
                    <div id="scan-status" class="hidden"></div>
                </div>
                
                <div class="form-group">
                    <label for="wifi-network-select">Select Network</label>
                    <select id="wifi-network-select" onchange="onNetworkSelect()">
                        <option value="">Select a network...</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="wifi-password">Password</label>
                    <input type="password" id="wifi-password" placeholder="Enter WiFi password">
                </div>
                
                <div class="action-buttons">
                    <button onclick="testConnection()" id="test-button" disabled>Test Connection</button>
                    <button onclick="saveConnection()" id="save-button" disabled>Save & Connect</button>
                </div>
                
                <div id="wifi-message" class="hidden"></div>
            </div>
            
            <div class="card">
                <h3>Current WiFi Settings</h3>
                <p>Network: <span id="current-wifi-ssid">None</span></p>
                <button onclick="disconnectWiFi()" id="disconnect-button" disabled>Disconnect & Clear</button>
            </div>
        </div>
        
        <!-- Settings Tab -->
        <div id="settings" class="tabcontent">
            <h2>WiFi Settings</h2>
            <div class="form-group">
                <label for="ap-ssid">Access Point SSID</label>
                <input type="text" id="ap-ssid">
            </div>
            <div class="form-group">
                <label for="ap-password">Access Point Password</label>
                <input type="password" id="ap-password">
            </div>
            <button onclick="saveWifiSettings()">Save WiFi Settings</button>
            
            <h2>Color Settings</h2>
            <div class="form-group">
                <label for="color-0">0째 Position Color</label>
                <input type="color" id="color-0">
                <div class="color-preview" id="preview-0"></div>
            </div>
            <div class="form-group">
                <label for="color-90">90째 Position Color</label>
                <input type="color" id="color-90">
                <div class="color-preview" id="preview-90"></div>
            </div>
            <div class="form-group">
                <label for="color-180">180째 Position Color</label>
                <input type="color" id="color-180">
                <div class="color-preview" id="preview-180"></div>
            </div>
            <div class="form-group">
                <label for="color-270">270째 Position Color</label>
                <input type="color" id="color-270">
                <div class="color-preview" id="preview-270"></div>
            </div>
            <button onclick="saveColorSettings()">Save Color Settings</button>
            
            <h2>Reset to Defaults</h2>
            <button onclick="resetSettings()">Reset All Settings</button>
        </div>
        
        <!-- Calibration Tab -->
        <div id="calibration" class="tabcontent">
            <h2>Position Calibration</h2>
            <p>Set the current physical position as the new zero reference point. This will maintain the relative spacing between all calibrated positions.</p>
            <div class="action-buttons">
                <button onclick="setZeroPosition()">Set Zero Position</button>
            </div>

            <h2>Full Revolution Count</h2>
            <p>How many counts is a full revolution?</p>
            <div class="form-group">
                <label for="full-rotation-count">Full Rotation (encoder counts)</label>
                <input type="number" id="full-rotation-count" placeholder="Enter position in counts">
                <button id="goto-button" onclick="saveFullRotationSettings()">Set Full Rotation Count</button>
            </div>
            
            <h2>Go to Position</h2>
            <p>Move to a specific encoder position for testing or calibration.</p>
            <div class="form-group">
                <label for="goto-position">Target Position (encoder counts)</label>
                <input type="number" id="goto-position" placeholder="Enter position in counts">
                <button id="goto-button" onclick="gotoPosition()">Go to Position</button>
            </div>
            <div id="goto-status" class="hidden"></div>
            
            <h2>Fine Tuning</h2>
            <div class="form-group">
                <label for="nudge-position">Nudge position</label>
                <input type="number" id="nudge-position" value="100">
            </div>
            <div class="action-buttons">
                <button onclick="nudgePosition(true)">Nudge Forward</button>
                <button onclick="nudgePosition(false)">Nudge Backward</button>
            </div>
            
            <p>Current detected angle: <span id="calibration-current-angle">-</span>째</p>
            <div class="form-group">
                <label for="pos-0-degrees">0째 Position (encoder counts)</label>
                <input type="number" id="pos-0-degrees">
            </div>
            <div class="form-group">
                <label for="pos-90-degrees">90째 Position (encoder counts)</label>
                <input type="number" id="pos-90-degrees">
            </div>
            <div class="form-group">
                <label for="pos-180-degrees">180째 Position (encoder counts)</label>
                <input type="number" id="pos-180-degrees">
            </div>
            <div class="form-group">
                <label for="pos-270-degrees">270째 Position (encoder counts)</label>
                <input type="number" id="pos-270-degrees">
            </div>
            <button onclick="savePositionSettings()">Save Position Settings</button>
        </div>
        
        <!-- Motion Control Tab -->
        <div id="motion-control" class="tabcontent">
            <h2>Motion Control Configuration</h2>
            <p>Configure motion control parameters for precise positioning and smooth movement.</p>
            
            <div class="form-group">
                <label for="position-hysteresis">Position Hysteresis (encoder counts)</label>
                <input type="number" id="position-hysteresis" min="1" max="1000" step="1">
                <small>Tolerance around target position before stopping (default: 20)</small>
            </div>
            
            <div class="form-group">
                <label for="max-speed">Maximum Speed (counts/second)</label>
                <input type="number" id="max-speed" min="100" max="20000" step="100">
                <small>Maximum rotational speed (default: 6000)</small>
            </div>
            
            <div class="form-group">
                <label for="acceleration">Acceleration (counts/second짼)</label>
                <input type="number" id="acceleration" min="100" max="20000" step="100">
                <small>Acceleration/deceleration rate (default: 4000)</small>
            </div>
            
            <h3>PID Controller Gains</h3>
            <p>Adjust these carefully - small changes can significantly affect performance.</p>
            
            <div class="form-group">
                <label for="vel-loop-p">Proportional Gain (P)</label>
                <input type="text" id="vel-loop-p" pattern="[+-]?([0-9]*[.])?[0-9]+([eE][+-]?[0-9]+)?">
                <small>Proportional response to speed error (default: 3e-5)</small>
            </div>
            
            <div class="form-group">
                <label for="vel-loop-i">Integral Gain (I)</label>
                <input type="text" id="vel-loop-i" pattern="[+-]?([0-9]*[.])?[0-9]+([eE][+-]?[0-9]+)?">
                <small>Response to accumulated speed error (default: 6e-3)</small>
            </div>
            
            <div class="form-group">
                <label for="vel-loop-d">Derivative Gain (D)</label>
                <input type="text" id="vel-loop-d" pattern="[+-]?([0-9]*[.])?[0-9]+([eE][+-]?[0-9]+)?">
                <small>Response to rate of speed error change (default: -2e-8)</small>
            </div>
            
            <h3>Filter Settings</h3>
            
            <div class="form-group">
                <label for="vel-filter-persistence">Velocity Filter Persistence</label>
                <input type="number" id="vel-filter-persistence" min="0" max="1" step="0.01">
                <small>Velocity smoothing factor, 0=no filtering, 1=maximum filtering (default: 0.0)</small>
            </div>
            
            <div class="form-group">
                <label for="spd-err-persistence">Speed Error Persistence</label>
                <input type="number" id="spd-err-persistence" min="0" max="1" step="0.01">
                <small>Speed error derivative smoothing factor (default: 0.0)</small>
            </div>
            
            <button onclick="saveMotionControlSettings()">Save Motion Control Settings</button>
            <button onclick="resetMotionControlToDefaults()">Reset to Defaults</button>
        </div>
        
        <!-- Debug Tab -->
        <div id="debug" class="tabcontent">
            <h2>Motion Control Debug</h2>
            <div class="debug-controls">
                <button id="debug-toggle" onclick="toggleDebug()">Start Debug</button>
                <button id="debug-clear" onclick="clearPlots()">Clear Plots</button>
                <div class="debug-status">
                    Status: <span id="debug-status">Stopped</span> | 
                    Connection: <span id="debug-connection">Disconnected</span> |
                    Data Points: <span id="debug-points">0</span>
                </div>
            </div>
            
            <div class="plot-container">
                <h3>Position Tracking</h3>
                <canvas id="position-plot" width="750" height="250"></canvas>
                <div class="plot-legend">
                    <span class="legend-item"><span class="legend-color" style="background-color: #3498db;"></span>Current Position</span>
                    <span class="legend-item"><span class="legend-color" style="background-color: #2ecc71;"></span>Current Velocity</span>
                    <span class="legend-item"><span class="legend-color" style="background-color: #e74c3c;"></span>Target Position</span>
                </div>
            </div>
            
            <div class="plot-container">
                <h3>PID Error Terms</h3>
                <canvas id="error-plot" width="750" height="250"></canvas>
                <div class="plot-legend">
                    <span class="legend-item"><span class="legend-color" style="background-color: #2ecc71;"></span>Speed Error</span>
                    <span class="legend-item"><span class="legend-color" style="background-color: #f39c12;"></span>Error Integral</span>
                    <span class="legend-item"><span class="legend-color" style="background-color: #9b59b6;"></span>Error Derivative</span>
                </div>
            </div>
        </div>
        
        <!-- Updates Tab -->
        <div id="updates" class="tabcontent">
            <h2>OTA Firmware Update</h2>
            <form id="ota-form" enctype="multipart/form-data">
                <div class="form-group">
                    <label for="firmware">Select Firmware File</label>
                    <input type="file" id="firmware" name="firmware" accept=".bin">
                </div>
                <button type="button" onclick="uploadFirmware()">Upload Firmware</button>
            </form>
            <div id="ota-progress" class="hidden">
                <div id="ota-progress-bar"></div>
            </div>
            <div id="ota-status" class="hidden"></div>
        </div>
        
        <div id="loading" class="loading hidden">
            <div class="loader"></div>
            <p>Loading...</p>
        </div>
    </div>

    <script>
        // Global variables
        let statusUpdateInterval;
        let currentStatus = {};
        let configData = null;  // Store config separately from status
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            fetchStatus();
            fetchConfig();  // Load config once at startup
            fetchWiFiStatus(); // Load WiFi status
            
            // Setup color picker previews
            document.getElementById('color-0').addEventListener('input', function() {
                updateColorPreview('preview-0', this.value);
            });
            document.getElementById('color-90').addEventListener('input', function() {
                updateColorPreview('preview-90', this.value);
            });
            document.getElementById('color-180').addEventListener('input', function() {
                updateColorPreview('preview-180', this.value);
            });
            document.getElementById('color-270').addEventListener('input', function() {
                updateColorPreview('preview-270', this.value);
            });
            
            // Start periodic status updates
            statusUpdateInterval = setInterval(fetchStatus, 2000);
        });
        
        // Tab handling
        function openTab(evt, tabName) {
            let tabcontent = document.getElementsByClassName("tabcontent");
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].classList.remove("active-tab");
            }
            
            let tablinks = document.getElementsByClassName("tablinks");
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].classList.remove("active");
            }
            
            document.getElementById(tabName).classList.add("active-tab");
            evt.currentTarget.classList.add("active");
            
            // Refresh status when showing certain tabs
            if (tabName === 'calibration') {
                fetchStatus();
            } else if (tabName === 'wifi') {
                fetchWiFiStatus();
            }
        }
        
        // Fetch current status from the device
        function fetchStatus() {
            fetch('/api/status')
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error('Failed to fetch status');
                    }
                })
                .then(data => {
                    currentStatus = data;
                    updateStatusDisplay(data);
                })
                .catch(error => console.error('Error fetching status:', error));
        }

        // Fetch configuration from the device
        function fetchConfig() {
            console.log('Fetching config...');
            fetch('/api/config')
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error('Failed to fetch config');
                    }
                })
                .then(data => {
                    console.log('Config data received:', data);
                    configData = data;
                    updateConfigDisplay(data);
                })
                .catch(error => {
                    console.error('Error fetching config:', error);
                });
        }
        
        // Update only the status display elements
        function updateStatusDisplay(data) {
            if (!data) {
                console.error('No data received in updateStatusDisplay');
                return;
            }

            // Update angle and position
            if (data.currentAngle !== undefined) {
                document.getElementById('current-angle').textContent = data.currentAngle + '째';
                document.getElementById('calibration-current-angle').textContent = data.currentAngle;
            }
            
            if (data.currentPosition !== undefined) {
                document.getElementById('current-position-counts').textContent = data.currentPosition + ' counts';
            }
            
            // Update color display - convert decimal to hex
            if (data.currentColor !== undefined) {
                const colorHex = '#' + data.currentColor.toString(16).padStart(6, '0');
                document.getElementById('current-color').style.backgroundColor = colorHex;
            }
            
            // Update auto rotation status
            if (data.autoRotationEnabled !== undefined) {
                document.getElementById('auto-rotation-status').textContent = data.autoRotationEnabled ? 'ON' : 'OFF';
                document.getElementById('auto-rotation-toggle').checked = data.autoRotationEnabled;
            }
        }
        
        // Update only config-related form fields
        function updateConfigDisplay(data) {
            console.log('Updating config display with data:', data);
            
            try {
                // Position calibration
                const pos0 = document.getElementById('pos-0-degrees');
                const pos90 = document.getElementById('pos-90-degrees');
                const pos180 = document.getElementById('pos-180-degrees');
                const pos270 = document.getElementById('pos-270-degrees');

                const full_rotation_count = document.getElementById('full-rotation-count');
                
                
                if (pos0) pos0.value = data.pos_0_degrees;
                if (pos90) pos90.value = data.pos_90_degrees;
                if (pos180) pos180.value = data.pos_180_degrees;
                if (pos270) pos270.value = data.pos_270_degrees;
                if (full_rotation_count) full_rotation_count.value = data.full_rotation_count;

                
                // Colors
                updateColorField('color-0', 'preview-0', data.color_0);
                updateColorField('color-90', 'preview-90', data.color_90);
                updateColorField('color-180', 'preview-180', data.color_180);
                updateColorField('color-270', 'preview-270', data.color_270);
                
                // WiFi settings
                const apSsid = document.getElementById('ap-ssid');
                const apPassword = document.getElementById('ap-password');
                
                console.log('WiFi elements found:', {apSsid, apPassword});
                
                if (apSsid) apSsid.value = data.ap_ssid;
                if (apPassword) apPassword.value = data.ap_password || '';
                
                // Rotation interval
                const rotationInterval = document.getElementById('rotation-interval');
                console.log('Rotation interval element found:', rotationInterval);
                
                if (rotationInterval) rotationInterval.value = data.rotation_interval;
                
                // Motion control parameters
                if (data.position_hysteresis !== undefined) {
                    const posHysteresis = document.getElementById('position-hysteresis');
                    if (posHysteresis) posHysteresis.value = data.position_hysteresis;
                }
                
                if (data.max_speed !== undefined) {
                    const maxSpeed = document.getElementById('max-speed');
                    if (maxSpeed) maxSpeed.value = data.max_speed;
                }
                
                if (data.acceleration !== undefined) {
                    const acceleration = document.getElementById('acceleration');
                    if (acceleration) acceleration.value = data.acceleration;
                }
                
                if (data.vel_loop_p !== undefined) {
                    const velLoopP = document.getElementById('vel-loop-p');
                    if (velLoopP) velLoopP.value = data.vel_loop_p.toExponential();
                }
                
                if (data.vel_loop_i !== undefined) {
                    const velLoopI = document.getElementById('vel-loop-i');
                    if (velLoopI) velLoopI.value = data.vel_loop_i.toExponential();
                }
                
                if (data.vel_loop_d !== undefined) {
                    const velLoopD = document.getElementById('vel-loop-d');
                    if (velLoopD) velLoopD.value = data.vel_loop_d.toExponential();
                }
                
                if (data.vel_filter_persistence !== undefined) {
                    const velFilterPersistence = document.getElementById('vel-filter-persistence');
                    if (velFilterPersistence) velFilterPersistence.value = data.vel_filter_persistence;
                }
                
                if (data.spd_err_persistence !== undefined) {
                    const spdErrPersistence = document.getElementById('spd-err-persistence');
                    if (spdErrPersistence) spdErrPersistence.value = data.spd_err_persistence;
                }
                
            } catch (error) {
                console.error('Error in updateConfigDisplay:', error);
            }
        }
        
        // Update a color input field and its preview
        function updateColorField(fieldId, previewId, colorValue) {
            if (colorValue !== undefined) {
                // Convert decimal to hex and ensure 6 digits with leading zeros
                const hexColor = '#' + colorValue.toString(16).padStart(6, '0');
                document.getElementById(fieldId).value = hexColor;
                updateColorPreview(previewId, hexColor);
            }
        }
        
        // Update a color preview element
        function updateColorPreview(previewId, color) {
            document.getElementById(previewId).style.backgroundColor = color;
        }
        
        // Command a rotation to a specific angle
        function rotate(angle) {
            showLoading();
            
            const formData = new FormData();
            formData.append('angle', angle);
            
            fetch('/api/rotate', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                hideLoading();
                if (response.ok) {
                    // Update the status after a short delay to allow rotation to start
                    setTimeout(fetchStatus, 500);
                } else {
                    alert('Failed to command rotation');
                }
            })
            .catch(error => {
                hideLoading();
                console.error('Error rotating:', error);
                alert('Error: ' + error.message);
            });
        }

        function nudgePosition(forward) {
            const nudgeSize = parseInt(document.getElementById('nudge-position').value);
            const currPos = currentStatus.currentPosition;

            if (isNaN(nudgeSize)) {
                showGotoStatus('Please enter a valid nudge size', 'error');
                return;
            }

            const formData = new FormData();
            if(forward == true){
                formData.append('position', currPos + nudgeSize);
            }
            else{
                formData.append('position', currPos - nudgeSize);
            }
            
            fetch('/api/goto', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                hideLoading();
                if (response.ok) {
                    // Update the status after a short delay to allow rotation to start
                    setTimeout(fetchStatus, 100);
                } else {
                    console.error('Error commanding nudging:', error);
                    alert('Failed to command rotation');
                }
            })
            .catch(error => {
                hideLoading();
                console.error('Error nudging:', error);
                alert('Error: ' + error.message);
            });
        }
        
        // Set the current position as the new zero reference point
        function setZeroPosition() {
            if (!confirm('This will set the current position as the new zero reference point while maintaining the relative spacing between all calibrated positions. Continue?')) {
                return;
            }
            
            showLoading();
            
            fetch('/api/set-zero', {
                method: 'POST'
            })
            .then(response => {
                hideLoading();
                if (response.ok) {
                    alert('Zero position set successfully! All calibrated positions have been updated.');
                    fetchConfig(); // Refresh the config to show updated values
                } else {
                    alert('Failed to set zero position');
                }
            })
            .catch(error => {
                hideLoading();
                console.error('Error setting zero position:', error);
                alert('Error: ' + error.message);
            });
        }
        
        // Go to a specific position in encoder counts
        function gotoPosition() {
            const positionInput = document.getElementById('goto-position');
            const gotoButton = document.getElementById('goto-button');
            const statusDiv = document.getElementById('goto-status');
            
            const targetPosition = parseInt(positionInput.value);
            
            // Validate input
            if (isNaN(targetPosition)) {
                showGotoStatus('Please enter a valid position number', 'error');
                return;
            }
            
            // Disable button during motion
            gotoButton.disabled = true;
            gotoButton.textContent = 'Moving...';
            showGotoStatus('Moving to position ' + targetPosition + '...', 'info');
            
            const formData = new FormData();
            formData.append('position', targetPosition);
            
            fetch('/api/goto', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (response.ok) {
                    showGotoStatus('Movement command sent successfully', 'success');
                    // Update status after a short delay
                    setTimeout(fetchStatus, 500);
                    // Re-enable button after a delay
                    setTimeout(() => {
                        gotoButton.disabled = false;
                        gotoButton.textContent = 'Go to Position';
                    }, 2000);
                } else {
                    showGotoStatus('Failed to send movement command', 'error');
                    gotoButton.disabled = false;
                    gotoButton.textContent = 'Go to Position';
                }
            })
            .catch(error => {
                console.error('Error going to position:', error);
                showGotoStatus('Error: ' + error.message, 'error');
                gotoButton.disabled = false;
                gotoButton.textContent = 'Go to Position';
            });
        }
        
        // Show status message for goto position
        function showGotoStatus(message, type) {
            const statusDiv = document.getElementById('goto-status');
            statusDiv.textContent = message;
            statusDiv.className = type; // 'success', 'error', or 'info'
            statusDiv.classList.remove('hidden');
            
            // Auto-hide after 5 seconds for success/info messages
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusDiv.classList.add('hidden');
                }, 5000);
            }
        }
        
        // Toggle auto-rotation
        function toggleAutoRotation() {
            const enabled = document.getElementById('auto-rotation-toggle').checked;
            saveSettings({
                auto_rotation_enabled: enabled
            });
        }
        
        // Save rotation interval
        function saveRotationInterval() {
            const interval = parseInt(document.getElementById('rotation-interval').value);
            if (isNaN(interval) || interval < 5) {
                alert('Please enter a valid interval (minimum 5 seconds)');
                return;
            }
            
            saveSettings({
                rotation_interval: interval
            });
        }
        
        // Save WiFi settings
        function saveWifiSettings() {
            const ssid = document.getElementById('ap-ssid').value.trim();
            const password = document.getElementById('ap-password').value;
            
            if (!ssid) {
                alert('SSID cannot be empty');
                return;
            }
            
            saveSettings({
                ap_ssid: ssid,
                ap_password: password
            });
        }
        
        // Save color settings
        function saveColorSettings() {
            const color0 = parseInt(document.getElementById('color-0').value.substring(1), 16);
            const color90 = parseInt(document.getElementById('color-90').value.substring(1), 16);
            const color180 = parseInt(document.getElementById('color-180').value.substring(1), 16);
            const color270 = parseInt(document.getElementById('color-270').value.substring(1), 16);
            
            saveSettings({
                color_0: color0,
                color_90: color90,
                color_180: color180,
                color_270: color270
            });
        }
        
        // Save position settings
        function savePositionSettings() {
            const pos0 = parseInt(document.getElementById('pos-0-degrees').value);
            const pos90 = parseInt(document.getElementById('pos-90-degrees').value);
            const pos180 = parseInt(document.getElementById('pos-180-degrees').value);
            const pos270 = parseInt(document.getElementById('pos-270-degrees').value);
            
            if (isNaN(pos0) || isNaN(pos90) || isNaN(pos180) || isNaN(pos270)) {
                alert('All position values must be valid numbers');
                return;
            }
            
            saveSettings({
                pos_0_degrees: pos0,
                pos_90_degrees: pos90,
                pos_180_degrees: pos180,
                pos_270_degrees: pos270
            });
        }
        
        function saveFullRotationSettings() {
            const full_rotation_count = parseInt(document.getElementById('full-rotation-count').value);
            
            if (isNaN(full_rotation_count)) {
                alert('Full revolution count must be a valid number');
                return;
            }
            
            saveSettings({
                full_rotation_count: full_rotation_count,
            });
        }
        
        // Save motion control settings
        function saveMotionControlSettings() {
            // Get basic parameters
            const positionHysteresis = parseInt(document.getElementById('position-hysteresis').value);
            const maxSpeed = parseFloat(document.getElementById('max-speed').value);
            const acceleration = parseFloat(document.getElementById('acceleration').value);
            
            // Get PID gains (handle scientific notation)
            const velLoopP = parseFloat(document.getElementById('vel-loop-p').value);
            const velLoopI = parseFloat(document.getElementById('vel-loop-i').value);
            const velLoopD = parseFloat(document.getElementById('vel-loop-d').value);
            
            // Get filter settings
            const velFilterPersistence = parseFloat(document.getElementById('vel-filter-persistence').value);
            const spdErrPersistence = parseFloat(document.getElementById('spd-err-persistence').value);
            
            // Validate inputs
            if (isNaN(positionHysteresis) || positionHysteresis < 1) {
                alert('Position hysteresis must be a positive integer');
                return;
            }
            
            if (isNaN(maxSpeed) || maxSpeed < 100) {
                alert('Maximum speed must be at least 100 counts/second');
                return;
            }
            
            if (isNaN(acceleration) || acceleration < 100) {
                alert('Acceleration must be at least 100 counts/second짼');
                return;
            }
            
            if (isNaN(velLoopP) || isNaN(velLoopI) || isNaN(velLoopD)) {
                alert('All PID gains must be valid numbers (scientific notation allowed)');
                return;
            }
            
            if (isNaN(velFilterPersistence) || velFilterPersistence < 0 || velFilterPersistence > 1) {
                alert('Velocity filter persistence must be between 0 and 1');
                return;
            }
            
            if (isNaN(spdErrPersistence) || spdErrPersistence < 0 || spdErrPersistence > 1) {
                alert('Speed error persistence must be between 0 and 1');
                return;
            }
            
            saveSettings({
                position_hysteresis: positionHysteresis,
                max_speed: maxSpeed,
                acceleration: acceleration,
                vel_loop_p: velLoopP,
                vel_loop_i: velLoopI,
                vel_loop_d: velLoopD,
                vel_filter_persistence: velFilterPersistence,
                spd_err_persistence: spdErrPersistence
            });
        }
        
        // Reset motion control settings to defaults
        function resetMotionControlToDefaults() {
            if (!confirm('Reset motion control parameters to default values?')) {
                return;
            }
            
            // Set default values
            document.getElementById('position-hysteresis').value = 20;
            document.getElementById('max-speed').value = 6000;
            document.getElementById('acceleration').value = 4000;
            document.getElementById('vel-loop-p').value = '3e-5';
            document.getElementById('vel-loop-i').value = '6e-3';
            document.getElementById('vel-loop-d').value = '-2e-8';
            document.getElementById('vel-filter-persistence').value = 0.0;
            document.getElementById('spd-err-persistence').value = 0.0;
            
            // Save the defaults
            saveMotionControlSettings();
        }
        
        // Generic settings save function
        function saveSettings(settings) {
            showLoading();
            
            fetch('/api/settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
            })
            .then(response => {
                hideLoading();
                if (response.ok) {
                    alert('Settings saved successfully');
                    fetchConfig();  // Refresh config after save
                } else {
                    alert('Failed to save settings');
                }
            })
            .catch(error => {
                hideLoading();
                console.error('Error saving settings:', error);
                alert('Error: ' + error.message);
            });
        }
        
        // Reset all settings to defaults
        function resetSettings() {
            if (!confirm('Are you sure you want to reset all settings to defaults?')) {
                return;
            }
            
            showLoading();
            
            fetch('/api/reset', {
                method: 'POST'
            })
            .then(response => {
                hideLoading();
                if (response.ok) {
                    alert('Settings reset to defaults');
                    fetchConfig();  // Refresh config after reset
                } else {
                    alert('Failed to reset settings');
                }
            })
            .catch(error => {
                hideLoading();
                console.error('Error resetting settings:', error);
                alert('Error: ' + error.message);
            });
        }
        
        // Upload firmware for OTA update
        function uploadFirmware() {
            const fileInput = document.getElementById('firmware');
            if (!fileInput.files.length) {
                alert('Please select a firmware file');
                return;
            }
            
            const file = fileInput.files[0];
            const formData = new FormData();
            formData.append('firmware', file);
            
            // Show progress elements
            document.getElementById('ota-progress').classList.remove('hidden');
            document.getElementById('ota-status').classList.remove('hidden');
            document.getElementById('ota-status').textContent = 'Starting upload...';
            
            // Reset progress bar
            document.getElementById('ota-progress-bar').style.width = '0%';
            
            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/update', true);
            
            xhr.upload.onprogress = function(event) {
                if (event.lengthComputable) {
                    const percentComplete = (event.loaded / event.total) * 100;
                    document.getElementById('ota-progress-bar').style.width = percentComplete + '%';
                    document.getElementById('ota-status').textContent = 'Uploading: ' + percentComplete.toFixed(1) + '%';
                }
            };
            
            xhr.onload = function() {
                if (xhr.status === 200) {
                    document.getElementById('ota-status').textContent = 'Update successful. Device is rebooting...';
                    document.getElementById('ota-progress-bar').style.width = '100%';
                    document.getElementById('ota-progress-bar').style.backgroundColor = '#4CAF50';
                    
                    // Stop status updates during reboot
                    clearInterval(statusUpdateInterval);
                    
                    // Try to reconnect after a delay
                    setTimeout(function() {
                        document.getElementById('ota-status').textContent = 'Attempting to reconnect...';
                        attemptReconnect();
                    }, 10000);
                } else {
                    document.getElementById('ota-status').textContent = 'Update failed: ' + xhr.responseText;
                    document.getElementById('ota-progress-bar').style.backgroundColor = '#F44336';
                }
            };
            
            xhr.onerror = function() {
                document.getElementById('ota-status').textContent = 'Update failed due to network error';
                document.getElementById('ota-progress-bar').style.backgroundColor = '#F44336';
            };
            
            xhr.send(formData);
        }
        
        // Attempt to reconnect after OTA update
        function attemptReconnect() {
            fetch('/api/status')
                .then(response => {
                    if (response.ok) {
                        document.getElementById('ota-status').textContent = 'Connected successfully to updated device!';
                        // Restart status updates
                        statusUpdateInterval = setInterval(fetchStatus, 2000);
                        fetchStatus();
                    } else {
                        throw new Error('Device not ready');
                    }
                })
                .catch(error => {
                    document.getElementById('ota-status').textContent = 'Still waiting for device to come online...';
                    setTimeout(attemptReconnect, 5000);
                });
        }
        
        // Show loading indicator
        function showLoading() {
            document.getElementById('loading').classList.remove('hidden');
        }
        
        // Hide loading indicator
        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
        }
        
        // =============================================================================
        // WIFI FUNCTIONALITY
        // =============================================================================
        
        // Fetch WiFi status
        function fetchWiFiStatus() {
            fetch('/api/wifi/status')
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error('Failed to fetch WiFi status');
                    }
                })
                .then(data => {
                    updateWiFiStatusDisplay(data);
                })
                .catch(error => console.error('Error fetching WiFi status:', error));
        }
        
        // Update WiFi status display
        function updateWiFiStatusDisplay(data) {
            document.getElementById('wifi-status').textContent = data.status || '-';
            document.getElementById('wifi-ip').textContent = data.ip || '-';
            document.getElementById('current-wifi-ssid').textContent = data.ssid || 'None';
            document.getElementById('wifi-mdns').textContent = data.mdns_name ? `${data.mdns_name}.local` : '-';
            
            // Enable/disable disconnect button based on connection state
            const disconnectButton = document.getElementById('disconnect-button');
            disconnectButton.disabled = !data.client_enabled;
        }
        
        // Scan for WiFi networks
        function scanNetworks() {
            const scanButton = document.getElementById('scan-button');
            const scanStatus = document.getElementById('scan-status');
            const networkSelect = document.getElementById('wifi-network-select');
            
            scanButton.disabled = true;
            scanButton.textContent = 'Scanning...';
            scanStatus.textContent = 'Starting scan...';
            scanStatus.className = 'info';
            scanStatus.classList.remove('hidden');
            
            // Clear existing options
            networkSelect.innerHTML = '<option value="">Select a network...</option>';
            
            // Start scan
            fetch('/api/wifi/scan')
                .then(response => {
                    if (response.ok) {
                        scanStatus.textContent = 'Scanning for networks...';
                        // Poll for results
                        pollScanResults();
                    } else {
                        throw new Error('Failed to start scan');
                    }
                })
                .catch(error => {
                    console.error('Error starting scan:', error);
                    scanStatus.textContent = 'Failed to start scan';
                    scanStatus.className = 'error';
                    scanButton.disabled = false;
                    scanButton.textContent = 'Scan for Networks';
                });
        }
        
        // Poll for scan results
        function pollScanResults() {
            const scanButton = document.getElementById('scan-button');
            const scanStatus = document.getElementById('scan-status');
            const networkSelect = document.getElementById('wifi-network-select');
            
            fetch('/api/wifi/scan-results')
                .then(response => {
                    if (response.status === 202) {
                        // Still scanning, poll again
                        scanStatus.textContent = 'Scanning for networks...';
                        setTimeout(pollScanResults, 1000);
                        return null; // Don't process further
                    } else if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error('Scan failed');
                    }
                })
                .then(data => {
                    // Only process data if we actually got some (not null from 202 response)
                    if (data === null) {
                        return; // Exit early for 202 responses
                    }
                    
                    if (data && data.networks && data.networks.length > 0) {
                        data.networks.forEach(network => {
                            const option = document.createElement('option');
                            option.value = network.ssid;
                            option.textContent = `${network.ssid} (${network.rssi} dBm, ${network.encryption})`;
                            networkSelect.appendChild(option);
                        });
                        scanStatus.textContent = `Found ${data.networks.length} networks`;
                        scanStatus.className = 'success';
                        scanButton.disabled = false;
                        scanButton.textContent = 'Scan for Networks';
                    } else {
                        scanStatus.textContent = 'No networks found';
                        scanStatus.className = 'error';
                        scanButton.disabled = false;
                        scanButton.textContent = 'Scan for Networks';
                    }
                })
                .catch(error => {
                    console.error('Error getting scan results:', error);
                    scanStatus.textContent = 'Failed to get scan results';
                    scanStatus.className = 'error';
                    scanButton.disabled = false;
                    scanButton.textContent = 'Scan for Networks';
                });
        }
        
        // Handle network selection
        function onNetworkSelect() {
            const networkSelect = document.getElementById('wifi-network-select');
            const testButton = document.getElementById('test-button');
            const saveButton = document.getElementById('save-button');
            
            if (networkSelect.value) {
                testButton.disabled = false;
                saveButton.disabled = false;
            } else {
                testButton.disabled = true;
                saveButton.disabled = true;
            }
        }
        
        // Test WiFi connection
        function testConnection() {
            const networkSelect = document.getElementById('wifi-network-select');
            const passwordInput = document.getElementById('wifi-password');
            const testButton = document.getElementById('test-button');
            const wifiMessage = document.getElementById('wifi-message');
            
            const ssid = networkSelect.value;
            const password = passwordInput.value;
            
            if (!ssid) {
                showWiFiMessage('Please select a network', 'error');
                return;
            }
            
            testButton.disabled = true;
            testButton.textContent = 'Testing...';
            wifiMessage.textContent = 'Testing connection...';
            wifiMessage.className = 'info';
            wifiMessage.classList.remove('hidden');
            
            const formData = new FormData();
            formData.append('ssid', ssid);
            formData.append('password', password);
            
            fetch('/api/wifi/test', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (response.ok) {
                    showWiFiMessage('Connection test successful!', 'success');
                } else {
                    showWiFiMessage('Connection test failed. Check password.', 'error');
                }
            })
            .catch(error => {
                console.error('Error testing connection:', error);
                showWiFiMessage('Error testing connection: ' + error.message, 'error');
            })
            .finally(() => {
                testButton.disabled = false;
                testButton.textContent = 'Test Connection';
            });
        }
        
        // Save WiFi connection
        function saveConnection() {
            const networkSelect = document.getElementById('wifi-network-select');
            const passwordInput = document.getElementById('wifi-password');
            const saveButton = document.getElementById('save-button');
            
            const ssid = networkSelect.value;
            const password = passwordInput.value;
            
            if (!ssid) {
                showWiFiMessage('Please select a network', 'error');
                return;
            }
            
            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';
            showWiFiMessage('Saving WiFi credentials...', 'info');
            
            const formData = new FormData();
            formData.append('ssid', ssid);
            formData.append('password', password);
            
            fetch('/api/wifi/connect', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (response.ok) {
                    showWiFiMessage('WiFi credentials saved successfully! Device will restart.', 'success');
                    // Refresh status after a delay
                    setTimeout(() => {
                        fetchWiFiStatus();
                        fetchStatus();
                    }, 2000);
                } else {
                    showWiFiMessage('Failed to save WiFi credentials', 'error');
                }
            })
            .catch(error => {
                console.error('Error saving connection:', error);
                showWiFiMessage('Error saving connection: ' + error.message, 'error');
            })
            .finally(() => {
                saveButton.disabled = false;
                saveButton.textContent = 'Save & Connect';
            });
        }
        
        // Disconnect WiFi
        function disconnectWiFi() {
            if (!confirm('Are you sure you want to disconnect and clear WiFi credentials?')) {
                return;
            }
            
            const disconnectButton = document.getElementById('disconnect-button');
            disconnectButton.disabled = true;
            disconnectButton.textContent = 'Disconnecting...';
            showWiFiMessage('Disconnecting WiFi...', 'info');
            
            fetch('/api/wifi/disconnect', {
                method: 'POST'
            })
            .then(response => {
                if (response.ok) {
                    showWiFiMessage('WiFi disconnected and credentials cleared', 'success');
                    // Refresh status
                    setTimeout(() => {
                        fetchWiFiStatus();
                        fetchStatus();
                    }, 1000);
                } else {
                    showWiFiMessage('Failed to disconnect WiFi', 'error');
                }
            })
            .catch(error => {
                console.error('Error disconnecting WiFi:', error);
                showWiFiMessage('Error disconnecting WiFi: ' + error.message, 'error');
            })
            .finally(() => {
                disconnectButton.disabled = false;
                disconnectButton.textContent = 'Disconnect & Clear';
            });
        }
        
        // Show WiFi message
        function showWiFiMessage(message, type) {
            const wifiMessage = document.getElementById('wifi-message');
            wifiMessage.textContent = message;
            wifiMessage.className = type;
            wifiMessage.classList.remove('hidden');
            
            // Auto-hide success/info messages after 5 seconds
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    wifiMessage.classList.add('hidden');
                }, 5000);
            }
        }
        
        // =============================================================================
        // DEBUG FUNCTIONALITY
        // =============================================================================
        
        // Debug state variables
        let debugActive = false;
        let debugWebSocket = null;
        let debugDataBuffer = [];
        let debugTimer = null;
        let debugStartTime = Date.now();
        
        // Plot configuration
        const PLOT_BUFFER_SIZE = 1000;  // Maximum data points to keep
        const PLOT_WINDOW_SECONDS = 100; // Seconds of data to display
        const PLOT_UPDATE_RATE = 100;   // ms between plot updates
        
        // Colors for plotting
        const PLOT_COLORS = {
            currentPosition: '#3498db',
            currentVelocity: '#2ecc71',
            targetPosition: '#e74c3c',
            speedError: '#2ecc71',
            errorIntegral: '#f39c12',
            errorDerivative: '#9b59b6'
        };
        
        // Toggle debug on/off
        function toggleDebug() {
            if (debugActive) {
                stopDebug();
            } else {
                startDebug();
            }
        }
        
        // Start debug data collection and plotting
        function startDebug() {
            debugActive = true;
            debugStartTime = Date.now();
            
            // Update UI
            document.getElementById('debug-toggle').textContent = 'Stop Debug';
            document.getElementById('debug-status').textContent = 'Starting...';
            
            // Connect to WebSocket
            connectDebugWebSocket();
            
            // Start plot update timer
            debugTimer = setInterval(updatePlots, PLOT_UPDATE_RATE);
            
            console.log('Debug started');
        }
        
        // Stop debug data collection and plotting
        function stopDebug() {
            debugActive = false;
            
            // Update UI
            document.getElementById('debug-toggle').textContent = 'Start Debug';
            document.getElementById('debug-status').textContent = 'Stopped';
            document.getElementById('debug-connection').textContent = 'Disconnected';
            
            // Stop timers
            if (debugTimer) {
                clearInterval(debugTimer);
                debugTimer = null;
            }
            
            // Disconnect WebSocket
            disconnectDebugWebSocket();
            
            console.log('Debug stopped');
        }
        
        // Clear all plot data
        function clearPlots() {
            debugDataBuffer = [];
            debugStartTime = Date.now();
            updatePlots();
            updateDebugStats();
        }
        
        // Update debug statistics display
        function updateDebugStats() {
            document.getElementById('debug-points').textContent = debugDataBuffer.length;
        }
        
        // =============================================================================
        // WEBSOCKET IMPLEMENTATION
        // =============================================================================
        
        function connectDebugWebSocket() {
            try {
                // Construct WebSocket URL
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = protocol + '//' + window.location.host + '/ws/debug';
                
                console.log('Connecting to WebSocket:', wsUrl);
                document.getElementById('debug-connection').textContent = 'Connecting...';
                
                debugWebSocket = new WebSocket(wsUrl);
                debugWebSocket.onopen = onDebugWebSocketOpen;
                debugWebSocket.onmessage = onDebugWebSocketMessage;
                debugWebSocket.onclose = onDebugWebSocketClose;
                debugWebSocket.onerror = onDebugWebSocketError;
                
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                document.getElementById('debug-connection').textContent = 'Connection Failed';
                document.getElementById('debug-status').textContent = 'Error';
            }
        }
        
        function disconnectDebugWebSocket() {
            if (debugWebSocket) {
                console.log('Disconnecting WebSocket');
                
                // Send stop command to backend before disconnecting
                if (debugWebSocket.readyState === WebSocket.OPEN) {
                    debugWebSocket.send('stop');
                }
                
                debugWebSocket.close();
                debugWebSocket = null;
            }
        }
        
        function onDebugWebSocketOpen(event) {
            console.log('WebSocket connected');
            document.getElementById('debug-connection').textContent = 'Connected';
            document.getElementById('debug-status').textContent = 'Running';
            
            // Send start debug command to backend (plain string, not JSON)
            if (debugWebSocket && debugWebSocket.readyState === WebSocket.OPEN) {
                debugWebSocket.send('start');
            }
        }
        
        function onDebugWebSocketMessage(event) {
            try {
                const data = JSON.parse(event.data);
                
                // Validate required fields - all must come from backend
                if (data.timestamp !== undefined && 
                    data.currentPosition !== undefined && 
                    data.targetPosition !== undefined &&
                    data.speedError !== undefined &&
                    data.errorIntegral !== undefined &&
                    data.errorDerivative !== undefined) {
                    
                    // Use backend timestamp as-is (millis() since microcontroller boot)
                    // Do NOT mix with Date.now() as they are different time references
                    addDebugDataPoint(data);
                } else {
                    console.warn('Invalid debug data received (missing required fields):', data);
                    console.warn('Expected fields: timestamp, currentPosition, targetPosition, speedError, errorIntegral, errorDerivative');
                }
                
            } catch (error) {
                console.error('Failed to parse WebSocket message:', error, event.data);
            }
        }
        
        function onDebugWebSocketClose(event) {
            console.log('WebSocket disconnected:', event.code, event.reason);
            document.getElementById('debug-connection').textContent = 'Disconnected';
            
            if (debugActive) {
                // Attempt to reconnect if debug is still active
                setTimeout(() => {
                    if (debugActive) {
                        console.log('Attempting to reconnect WebSocket...');
                        connectDebugWebSocket();
                    }
                }, 2000);
            }
        }
        
        function onDebugWebSocketError(event) {
            console.error('WebSocket error:', event);
            document.getElementById('debug-connection').textContent = 'Error';
        }
        
        // =============================================================================
        // DATA MANAGEMENT
        // =============================================================================
        
        // Add a new data point to the buffer
        function addDebugDataPoint(dataPoint) {
            debugDataBuffer.push(dataPoint);
            
            // Limit buffer size
            if (debugDataBuffer.length > PLOT_BUFFER_SIZE) {
                debugDataBuffer.shift();
            }
            
            updateDebugStats();
        }
        
        // Get data points within the display window
        function getDisplayData() {
            if (debugDataBuffer.length === 0) return [];
            
            // Use the most recent data point's timestamp as reference
            // (backend sends millis() since boot, not Unix timestamp)
            const mostRecentTimestamp = debugDataBuffer[debugDataBuffer.length - 1].timestamp;
            const windowStart = mostRecentTimestamp - (PLOT_WINDOW_SECONDS * 1000);
            
            return debugDataBuffer.filter(point => point.timestamp >= windowStart);
        }
        
        // =============================================================================
        // PLOTTING FUNCTIONS
        // =============================================================================
        
        // Update both plots
        function updatePlots() {
            updatePositionPlot();
            updateErrorPlot();
        }
        
        // Update the position tracking plot
        function updatePositionPlot() {
            const canvas = document.getElementById('position-plot');
            const ctx = canvas.getContext('2d');
            const data = getDisplayData();
            
            if (data.length === 0) {
                clearCanvas(ctx, canvas);
                return;
            }
            
            // Clear canvas
            clearCanvas(ctx, canvas);
            
            // Draw grid
            drawGrid(ctx, canvas);
            
            // Calculate scales using backend timestamps (millis() since boot)
            const timeRange = PLOT_WINDOW_SECONDS * 1000;
            const mostRecentTimestamp = data[data.length - 1].timestamp;
            const timeStart = mostRecentTimestamp - timeRange;
            
            const positions = data.flatMap(d => [d.currentPosition, d.targetPosition]);
            const posMin = Math.min(...positions);
            const posMax = Math.max(...positions);
            const posRange = posMax - posMin || 100;
            const posMargin = posRange * 0.1;
            
            // Draw position lines
            drawLine(ctx, canvas, data, 'currentPosition', PLOT_COLORS.currentPosition, 
                    timeStart, timeRange, posMin - posMargin, posRange + 2 * posMargin);
            drawLine(ctx, canvas, data, 'currentVelocity', PLOT_COLORS.currentVelocity, 
                    timeStart, timeRange, posMin - posMargin, posRange + 2 * posMargin);
            drawLine(ctx, canvas, data, 'targetPosition', PLOT_COLORS.targetPosition, 
                    timeStart, timeRange, posMin - posMargin, posRange + 2 * posMargin);
            
            // Draw axis labels
            drawAxisLabels(ctx, canvas, 'Time (s)', 'Position (counts)');
        }
        
        // Update the error terms plot
        function updateErrorPlot() {
            const canvas = document.getElementById('error-plot');
            const ctx = canvas.getContext('2d');
            const data = getDisplayData();
            
            if (data.length === 0) {
                clearCanvas(ctx, canvas);
                return;
            }
            
            // Clear canvas
            clearCanvas(ctx, canvas);
            
            // Draw grid
            drawGrid(ctx, canvas);
            
            // Calculate scales using backend timestamps (millis() since boot)
            const timeRange = PLOT_WINDOW_SECONDS * 1000;
            const mostRecentTimestamp = data[data.length - 1].timestamp;
            const timeStart = mostRecentTimestamp - timeRange;
            
            const errors = data.flatMap(d => [d.speedError, d.errorIntegral, d.errorDerivative]);
            const errorMin = Math.min(...errors);
            const errorMax = Math.max(...errors);
            const errorRange = errorMax - errorMin || 1;
            const errorMargin = errorRange * 0.1;
            
            // Draw error lines
            drawLine(ctx, canvas, data, 'speedError', PLOT_COLORS.speedError, 
                    timeStart, timeRange, errorMin - errorMargin, errorRange + 2 * errorMargin);
            drawLine(ctx, canvas, data, 'errorIntegral', PLOT_COLORS.errorIntegral, 
                    timeStart, timeRange, errorMin - errorMargin, errorRange + 2 * errorMargin);
            drawLine(ctx, canvas, data, 'errorDerivative', PLOT_COLORS.errorDerivative, 
                    timeStart, timeRange, errorMin - errorMargin, errorRange + 2 * errorMargin);
            
            // Draw axis labels
            drawAxisLabels(ctx, canvas, 'Time (s)', 'Error Terms');
        }
        
        // Clear canvas with white background
        function clearCanvas(ctx, canvas) {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Draw grid lines
        function drawGrid(ctx, canvas) {
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            
            // Vertical grid lines
            for (let x = 0; x <= canvas.width; x += canvas.width / 10) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y <= canvas.height; y += canvas.height / 6) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // Draw a data line
        function drawLine(ctx, canvas, data, property, color, timeStart, timeRange, valueMin, valueRange) {
            if (data.length < 2) return;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let firstPoint = true;
            for (const point of data) {
                const x = ((point.timestamp - timeStart) / timeRange) * canvas.width;
                const y = canvas.height - (((point[property] - valueMin) / valueRange) * canvas.height);
                
                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
        }
        
        // Draw axis labels
        function drawAxisLabels(ctx, canvas, xLabel, yLabel) {
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            // X-axis label
            ctx.fillText(xLabel, canvas.width / 2, canvas.height - 5);
            
            // Y-axis label (rotated)
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();
        }
    </script>
</body>
</html> 